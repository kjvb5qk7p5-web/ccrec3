<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Card Advisor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      max-width: 900px;
    }
    h1, h2, h3 {
      margin-bottom: 0.3rem;
    }
    .card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 16px;
    }
    label {
      display: block;
      margin-top: 8px;
      font-size: 0.9rem;
    }
    input, select, button, textarea {
      margin-top: 4px;
      padding: 6px 8px;
      font-size: 0.9rem;
    }
    input[type="number"] {
      width: 120px;
    }
    input[type="date"] {
      width: 150px;
    }
    select {
      min-width: 220px;
    }
    .new-purchase-card #category {
      width: 100%;
      min-width: 0;    /* override the 220px */
      box-sizing: border-box;
    }
    button {
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #ccc;
      background: #f4f4f4;
    }
    button.primary {
      background: #0b6efd;
      color: white;
      border-color: #0b6efd;
    }

    .credits-section h3 {
      margin: 0 0 4px;
      font-size: 0.95rem;
    }
    
    .credits-section + .credits-section {
      margin-top: 10px;
    }

    /* Bigger inputs & buttons only in the New Purchase section */
    .new-purchase-card input,
    .new-purchase-card select {
      font-size: 1.1rem;
    }
    .new-purchase-card button {
      font-size: 1.1rem;
    }
    /* Bigger recommendation text */
    .new-purchase-card #recommendationBox {
      font-size: 1.2rem;
    }
    .new-purchase-card #reasonBox {
      font-size: 1.1rem;
      margin-top: 0.9rem;  /* roughly “one extra line” of space */
    }

    /* TABLE STYLING – updated for iPhone width */
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.85rem;
      table-layout: fixed;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 4px 6px;
      text-align: left;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    th {
      background: #f7f7f7;
    }

    /* Logged purchases table: extra small font */
    #loggedTable {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.5rem;
    }
    #loggedTable th,
    #loggedTable td {
      padding: 2px 4px;
    }
    /* Column widths so it fits nicely on mobile */
    th:nth-child(1), td:nth-child(1) { width: 18%; } /* Date */
    th:nth-child(2), td:nth-child(2) { width: 14%; } /* Amount */
    th:nth-child(3), td:nth-child(3) { width: 24%; } /* Category */
    th:nth-child(4), td:nth-child(4) { width: 24%; } /* Channel */
    th:nth-child(5), td:nth-child(5) { width: 20%; } /* Card Used */

    /* Saved Merchant Benefits table */
    #benefitsTable {
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;       /* so widths are respected */
      font-size: 0.5rem;         /* smaller to fit on phone */
      margin-top: 6px;
    }
    
    #benefitsTable th,
    #benefitsTable td {
      border: 1px solid #ddd;
      padding: 3px 4px;
      text-align: left;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    #benefitsTable th {
      background: #f7f7f7;
    }
    
    /* Column widths (sum ≈ 100%) */
    #benefitsTable th:nth-child(1),
    #benefitsTable td:nth-child(1) { width: 17%; } /* Merchant */
    #benefitsTable th:nth-child(2),
    #benefitsTable td:nth-child(2) { width: 10%; } /* Card */
    #benefitsTable th:nth-child(3),
    #benefitsTable td:nth-child(3) { width: 15%; } /* Discount */
    #benefitsTable th:nth-child(4),
    #benefitsTable td:nth-child(4) { width: 15%; } /* Limit */
    #benefitsTable th:nth-child(5),
    #benefitsTable td:nth-child(5) { width: 16%; } /* Category */
    #benefitsTable th:nth-child(6),
    #benefitsTable td:nth-child(6) { width: 12%; } /* End date */
    #benefitsTable th:nth-child(7),
    #benefitsTable td:nth-child(7) { width: 15%; } /* Delete button */

    /* Expired merchant benefits – show in red */
    #benefitsTable tr.expired-benefit td {
      color: red;
    }

    .muted {
      color: #777;
      font-size: 0.8rem;
    }
    .credit-met {
      color: green;
      font-weight: 600;
    }
    .inline {
      display: inline-block;
      margin-right: 12px;
    }

    /* Card badges */
    .card-badge {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 600;
      border: 1px solid transparent;
      vertical-align: baseline;
      white-space: nowrap;
      line-height: 1.4;
      background: #f2f2f2;
      color: #333;
      border-color: #ccc;
    }
    .card-badge.csr {
      background: #e0ecff;
      border-color: #0047AB;
      color: #0047AB; /* CSR: #0047AB */
    }
    .card-badge.uq {
      background: #f2e6ff;
      border-color: #480080;
      color: #480080; /* UQ: #480080 */
    }
    .card-badge.mb {
      background: #f0f0f0;
      border-color: #999999;
      color: #555555; /* MB: #999999 as accent */
    }
    .card-badge.dg {
      background: #ffe6ea;
      border-color: #CE1126;
      color: #CE1126; /* DG: #CE1126 */
    }

    /* Make badges match tiny table font in these tables */
    #loggedTable .card-badge,
    #benefitsTable .card-badge {
      font-size: 0.5rem;
      padding: 1px 4px;
    }
  </style>
</head>
<body>
  <h1>Which Card Should I Use?</h1>
<p class="muted">
  CCrec3 brain for 4 cards: <br>
    &nbsp;&nbsp;&nbsp;- <span class="card-badge csr">CS</span> Chase Sapphire Reserve<br>
    &nbsp;&nbsp;&nbsp;- <span class="card-badge uq">UQ</span> United Quest<br>
    &nbsp;&nbsp;&nbsp;- <span class="card-badge mb">MB</span> Marriott Bonvoy Brilliant<br>
    &nbsp;&nbsp;&nbsp;- <span class="card-badge dg">DG</span> Delta SkyMiles Amex Gold<br>
</p>

  <!-- New purchase input -->
  <div class="card new-purchase-card">
    <h2>New Purchase</h2>
    <label>
      Amount ($)
      <input type="number" id="amount" min="0" step="0.01" />
    </label>

    <label>
      Date
      <input type="date" id="date" />
    </label>

    <label>
      Category
      <!-- Options will be populated dynamically from BASE_CATEGORIES + merchant benefits -->
      <select id="category"></select>
    </label>

    <div style="margin-top: 12px;">
      <button class="primary" id="btnRecommend">Get Card Recommendation</button>
      <button id="btnReset" type="button" style="margin-left:8px;">Reset</button>
    </div>

    <div id="recommendationSection" style="margin-top: 12px; display:none;">
      <div id="recommendationBox"></div>
      <div id="reasonBox"></div>

      <div style="margin-top: 10px;">
        <label>
          Card used (optional override)
          <select id="cardUsedSelect">
            <option value="">Use recommended card</option>
            <option value="CSR">CSR</option>
            <option value="UQ">United Quest</option>
            <option value="MB">Marriott Brilliant</option>
            <option value="DG">Delta Gold</option>
          </select>
        </label>

        <label>
          Channel used (optional override)
          <select id="channelUsedSelect">
            <!-- options populated dynamically based on category -->
          </select>
        </label>

        <div style="margin-top: 8px;">
          <button class="primary" id="btnSaveTx">Confirm &amp; Save Purchase</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Current month / year credit usage summary -->
  <div class="card">
    <h2>Current Credits & Offers Usage</h2>
    <div id="stateSummary" class="muted"></div>
  </div>

  <!-- Logged transactions -->
  <div class="card">
    <h2>Logged Purchases</h2>

    <button id="toggleLogBtn" style="margin-bottom:8px;">
      Show
    </button>

    <div id="logContent" style="display:none;">
      <table id="loggedTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Amount</th>
            <th>Category</th>
            <th>Channel</th>
            <th>Card Used</th>
          </tr>
        </thead>
        <tbody id="txTableBody"></tbody>
      </table>

      <button id="btnClear" style="margin-top:10px;">
        Clear All Logged Purchases
      </button>

      <p class="muted">
        Stored in your browser’s localStorage. Clearing your browser data will wipe this.
      </p>
    </div>
  </div>

  <!-- Merchant Benefits Management -->
  <div class="card">
    <h2>Merchant Benefits</h2>

    <button id="toggleBenefitsBtn" style="margin-bottom:8px;">
      Show
    </button>

    <div id="benefitsContent" style="display:none;">
      <h3 style="margin-top:0.2rem;">Add / Edit Benefit</h3>

      <label>
        Merchant
        <input type="text" id="benefitMerchant" placeholder="e.g., Starbucks" />
      </label>

      <label>
        Card
        <select id="benefitCard">
          <option value="CSR">CSR</option>
          <option value="UQ">United Quest</option>
          <option value="MB">Marriott Brilliant</option>
          <option value="DG">Delta Gold</option>
        </select>
      </label>

      <label>
        Discount type
        <select id="benefitDiscountType">
          <option value="percent">Percent (e.g. 10% back)</option>
          <option value="amount">Fixed amount ($ back)</option>
        </select>
      </label>

      <label>
        Discount value
        <input type="number" id="benefitDiscountValue" min="0" step="0.01" placeholder="e.g. 10 for 10% or $10" />
      </label>

      <label>
        Minimum spend per transaction (optional, in $)
        <input type="number" id="benefitMinSpend" min="0" step="0.01" placeholder="e.g. 50 means $50+ to trigger" />
      </label>

      <label>
        Max total benefit type
        <select id="benefitLimitType">
          <option value="per_tx">Per transaction</option>
          <option value="total">Total benefit cap</option>
        </select>
      </label>

      <label>
        Max total benefit value (optional, in $)
        <input type="number" id="benefitLimitValue" min="0" step="0.01" placeholder="e.g. 50 means up to $50 total" />
      </label>

      <label>
        Benefit end date
        <input type="date" id="benefitEndDate" />
      </label>

      <label>
        Category (for card recommendation logic)
        <select id="benefitCategory">
          <option value="dining">Dining / Restaurants</option>
          <option value="doordash">Doordash</option>
          <option value="lyft">Lyft</option>
          <option value="rideshare_other">Other rideshare (Uber, etc.)</option>
          <option value="united_flight">United flight</option>
          <option value="delta_flight_threshold">Delta flight – threshold chasing</option>
          <option value="delta_flight">Delta flight (not threshold)</option>
          <option value="other_flight">Other airline flight</option>
          <option value="marriott_hotel">Marriott hotel</option>
          <option value="renowned_hotel">Renowned hotel (United program)</option>
          <option value="delta_stays">Delta Stays hotel</option>
          <option value="other_hotel">Other hotel / lodging</option>
          <option value="stubhub">StubHub / viagogo</option>
          <option value="instacart">Instacart</option>
          <option value="streaming">Streaming</option>
          <option value="peloton">Peloton membership</option>
          <option value="other">Other / general</option>
        </select>
      </label>

      <button id="btnAddBenefit" class="primary" style="margin-top:8px;">
        Add Benefit
      </button>

      <h3 style="margin-top:12px;">Saved Benefits</h3>
      <table id="benefitsTable">
        <thead>
          <tr>
            <th>Merchant</th>
            <th>Card</th>
            <th>Discount</th>
            <th>Limit</th>
            <th>Category</th>
            <th>End Date</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="benefitsTbody"></tbody>
      </table>

      <p class="muted">
        Merchant benefits are stored locally in your browser (separate from purchases).
      </p>
    </div>
  </div>

  <script>
    const STORAGE_KEY = "cardAdvisorTxsV1";
    const MERCHANT_BENEFITS_KEY = "cardAdvisorMerchantBenefitsV1";

    // Base categories (what used to be hard-coded in the HTML select)
    const BASE_CATEGORIES = [
      { value: "dining",              label: "Dining / Restaurants" },
      { value: "doordash",            label: "Doordash" },
      { value: "lyft",                label: "Lyft" },
      { value: "rideshare_other",     label: "Other rideshare (Uber, etc.)" },
      { value: "united_flight",       label: "United flight" },
      { value: "delta_flight_threshold", label: "Delta flight – threshold chasing" },
      { value: "delta_flight",        label: "Delta flight (not threshold)" },
      { value: "other_flight",        label: "Other airline flight" },
      { value: "marriott_hotel",      label: "Marriott hotel" },
      { value: "renowned_hotel",      label: "Renowned hotel (United program)" },
      { value: "delta_stays",         label: "Delta Stays hotel" },
      { value: "other_hotel",         label: "Other hotel / lodging" },
      { value: "stubhub",             label: "StubHub / viagogo" },
      { value: "instacart",           label: "Instacart" },
      { value: "streaming",           label: "Streaming" },
      { value: "peloton",             label: "Peloton membership" },
      { value: "other",               label: "Other / general" }
    ];

    // Channel label mapping for human-readable text
    const CHANNEL_LABELS = {
      direct: "direct with the merchant",
      chase_travel: "via Chase Travel portal",
      lyft_app: "in the Lyft app",
      united: "on United.com / app",
      delta: "on Delta.com / app",
      renowned_chase: "via Renowned Hotels (Chase Travel)",
      delta_stays_platform: "on Delta Stays platform",
      stubhub_platform: "on StubHub / viagogo",
      instacart_platform: "on Instacart",
      peloton_platform: "on the Peloton site / app",
    };

    // Allowed channels per category (for override dropdown)
    const CHANNELS_BY_CATEGORY = {
      dining: ["direct"],
      doordash: ["direct"],
      lyft: ["lyft_app"],
      rideshare_other: ["direct"],
      united_flight: ["united"],
      delta_flight_threshold: ["delta"],
      delta_flight: ["delta"],
      other_flight: ["direct", "chase_travel"],
      marriott_hotel: ["direct"],
      renowned_hotel: ["renowned_chase"],
      delta_stays: ["delta_stays_platform"],
      other_hotel: ["direct", "chase_travel"],
      stubhub: ["stubhub_platform"],
      instacart: ["instacart_platform"],
      streaming: ["direct"],
      peloton: ["peloton_platform"],
      other: ["direct"],
    };

    function parseISODate(str) {
      if (!str) return null;
      const d = new Date(str);
      return isNaN(d.getTime()) ? null : d;
    }

    function formatTodayISO() {
      const today = new Date();
      const yyyy = today.getFullYear();
      const mm = String(today.getMonth() + 1).padStart(2, "0");
      const dd = String(today.getDate()).padStart(2, "0");
      return `${yyyy}-${mm}-${dd}`;
    }

    function startOfMonth(d) {
      return new Date(d.getFullYear(), d.getMonth(), 1);
    }

    // Render a card badge as HTML
    function renderCardBadge(code) {
      if (!code) return "";
      const c = String(code).toUpperCase();
      const cls = c.toLowerCase(); // csr, uq, mb, dg
      const label = c === "CSR" ? "CS" : c;
      return `<span class="card-badge ${cls}">${label}</span>`;
    }

    function escapeHtml(str) {
      if (str == null) return "";
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    // ---------- Transactions storage ----------
    function loadTransactions() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed;
      } catch {
        return [];
      }
    }

    function saveTransactions(txs) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(txs));
    }

    // ---------- Merchant benefits storage ----------
    function loadMerchantBenefits() {
      try {
        const raw = localStorage.getItem(MERCHANT_BENEFITS_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed;
      } catch {
        return [];
      }
    }

    function saveMerchantBenefits(benefits) {
      localStorage.setItem(MERCHANT_BENEFITS_KEY, JSON.stringify(benefits));
    }

    function findBenefitById(id, benefits) {
      return benefits.find((b) => b.id === id) || null;
    }

    // ---------- Render transactions ----------
    function renderTransactions() {
      const txs = loadTransactions();
      const tbody = document.getElementById("txTableBody");
      tbody.innerHTML = "";

      txs.forEach((tx) => {
        const tr = document.createElement("tr");
        const tdDate = document.createElement("td");
        const tdAmt = document.createElement("td");
        const tdCat = document.createElement("td");
        const tdChan = document.createElement("td");
        const tdCard = document.createElement("td");

        tdDate.textContent = tx.date || "";
        tdAmt.textContent = `$${Number(tx.amount || 0).toFixed(2)}`;
        tdCat.textContent = tx.category || "";
        tdChan.textContent = tx.channel || "";
        tdCard.innerHTML = tx.cardUsed ? renderCardBadge(tx.cardUsed) : "";

        tr.appendChild(tdDate);
        tr.appendChild(tdAmt);
        tr.appendChild(tdCat);
        tr.appendChild(tdChan);
        tr.appendChild(tdCard);

        tbody.appendChild(tr);
      });
    }

    // ---------- Card-native benefits state ----------
    function computeState(txs, now) {
      const nowDate = now || new Date();

      // Month and year boundaries
      const monthStart = startOfMonth(nowDate);
      const yearStart = new Date(nowDate.getFullYear(), 0, 1);

      // Semi-annual StubHub period:
      // Jan–Jun  => period starts Jan 1
      // Jul–Dec  => period starts Jul 1
      const stubhubPeriodStart =
        nowDate.getMonth() < 6
          ? new Date(nowDate.getFullYear(), 0, 1)
          : new Date(nowDate.getFullYear(), 6, 1);

      // Monthly
      let mbDiningThisMonth = 0;
      let csrDoordashThisMonth = 0;
      let csrLyftThisMonth = 0;
      let uqRideshareThisMonth = 0;
      let uqInstacartThisMonth = 0;
      let csrPelotonThisMonth = 0;

      // Semi-annual
      let csrStubhubThisPeriod = 0;

      // Annual / calendar-year
      let csrTravelYTD = 0;
      let dgDeltaStaysYTD = 0;
      let dg10kSpendYTD = 0;

      // Which categories we treat as "travel" for CSR travel credit tracking
      const CSR_TRAVEL_CATEGORIES = new Set([
        "united_flight",
        "delta_flight_threshold",
        "delta_flight",
        "other_flight",
        "marriott_hotel",
        "renowned_hotel",
        "delta_stays",
        "other_hotel",
        "lyft",
        "rideshare_other",
      ]);

      for (const tx of txs) {
        if (!tx.date) continue;
        const d = parseISODate(tx.date);
        if (!d) continue;

        const amt = Number(tx.amount) || 0;

        const inMonth = d >= monthStart && d <= nowDate;
        const inYear = d >= yearStart && d <= nowDate;
        const inStubhubPeriod = d >= stubhubPeriodStart && d <= nowDate;

        // Monthly-limited benefits
        if (inMonth) {
          if (tx.cardUsed === "MB" && tx.category === "dining") {
            mbDiningThisMonth += amt;
          }
          if (tx.cardUsed === "CSR" && tx.category === "doordash") {
            csrDoordashThisMonth += amt;
          }
          if (tx.cardUsed === "CSR" && tx.category === "lyft") {
            csrLyftThisMonth += amt;
          }
          if (tx.cardUsed === "UQ" && tx.category === "rideshare_other") {
            uqRideshareThisMonth += amt;
          }
          if (tx.cardUsed === "UQ" && tx.category === "instacart") {
            uqInstacartThisMonth += amt;
          }
          if (tx.cardUsed === "CSR" && tx.category === "peloton") {
            csrPelotonThisMonth += amt;
          }
        }

        // Semi-annual StubHub credit (CSR only)
        if (
          inStubhubPeriod &&
          tx.cardUsed === "CSR" &&
          tx.category === "stubhub"
        ) {
          csrStubhubThisPeriod += amt;
        }

        // Annual / calendar-year benefits
        if (inYear) {
          if (tx.cardUsed === "CSR" && CSR_TRAVEL_CATEGORIES.has(tx.category)) {
            csrTravelYTD += amt;
          }

          if (tx.cardUsed === "DG" && tx.category === "delta_stays") {
            dgDeltaStaysYTD += amt;
          }

          if (tx.cardUsed === "DG") {
            dg10kSpendYTD += amt;
          }
        }
      }

      return {
        mbDiningThisMonth,
        csrDoordashThisMonth,
        csrLyftThisMonth,
        uqRideshareThisMonth,
        uqInstacartThisMonth,
        csrPelotonThisMonth,
        csrStubhubThisPeriod,
        csrTravelYTD,
        dgDeltaStaysYTD,
        dg10kSpendYTD,
      };
    }

    // ---------- Merchant benefits usage state ----------
    function computeMerchantState(txs, benefits, now) {
      const nowDate = now || new Date();
      const state = {};

      for (const benefit of benefits) {
        let used = 0;
        const end = parseISODate(benefit.endDate);

        const minSpend =
          benefit.minSpend != null && !isNaN(benefit.minSpend)
            ? Number(benefit.minSpend)
            : null;

        for (const tx of txs) {
          if (!tx.date) continue;
          if (!tx.merchantBenefitId) continue;
          if (tx.merchantBenefitId !== benefit.id) continue;

          const d = parseISODate(tx.date);
          if (!d) continue;
          if (d > nowDate) continue;
          if (end && d > end) continue;

          if (tx.cardUsed && tx.cardUsed !== benefit.card) {
            // Logged with a different card than this benefit is on -> ignore
            continue;
          }

          const amount = Number(tx.amount) || 0;
          if (!amount) continue;

          // Enforce minimum spend per transaction if set
          if (minSpend != null && amount < minSpend) {
            continue;
          }

          let discount = 0;

          if (benefit.discountType === "percent") {
            discount = (amount * Number(benefit.discountValue || 0)) / 100;
          } else {
            discount = Number(benefit.discountValue || 0);
          }

          // Per-transaction cap, if specified
          if (
            benefit.limitType === "per_tx" &&
            benefit.limitValue != null &&
            !isNaN(benefit.limitValue)
          ) {
            discount = Math.min(discount, Number(benefit.limitValue));
          }

          // Total cap across all tx
          if (
            benefit.limitType === "total" &&
            benefit.limitValue != null &&
            !isNaN(benefit.limitValue)
          ) {
            const limit = Number(benefit.limitValue);
            const remaining = Math.max(0, limit - used);
            if (remaining <= 0) {
              discount = 0;
            } else {
              discount = Math.min(discount, remaining);
            }
          }

          used += discount;
        }

        state[benefit.id] = {
          used,
          limit: benefit.limitValue != null && !isNaN(benefit.limitValue)
            ? Number(benefit.limitValue)
            : null,
        };
      }

      return state;
    }

    function cardBadgeSpan(cardCode) {
      // Normalize the input
      const code = (cardCode || "").toUpperCase();
      let label = code;
      let variantClass = "";
    
      if (code === "CSR") {
        label = "CS";      // display text
        variantClass = "csr";
      } else if (code === "UQ") {
        label = "UQ";
        variantClass = "uq";
      } else if (code === "MB") {
        label = "MB";
        variantClass = "mb";
      } else if (code === "DG") {
        label = "DG";
        variantClass = "dg";
      }
    
      return `<span class="card-badge ${variantClass}">${label}</span>`;
    }

    // ---------- State summary ----------
    function renderStateSummary() {
      const txs = loadTransactions();
      const cardState = computeState(txs);
      const benefits = loadMerchantBenefits();
      const merchantState = computeMerchantState(txs, benefits);
      const el = document.getElementById("stateSummary");
    
      // Local helper for badges (matches your CSS + "CS" label for CSR)
      function cardBadge(code) {
        const normalized = (code || "").toUpperCase();
        let label = normalized;
        if (normalized === "CSR") label = "CS";
    
        const cls =
          normalized === "CSR"
            ? "csr"
            : normalized === "UQ"
            ? "uq"
            : normalized === "MB"
            ? "mb"
            : normalized === "DG"
            ? "dg"
            : "";
    
        return `<span class="card-badge ${cls}">${label}</span>`;
      }
    
      const ccLines = [];
      const merchantLines = [];
    
      // ---------- Credit card benefits (cardState) ----------
    
      // CSR: Travel credit (calendar year, $300)
      {
        const used = cardState.csrTravelYTD;
        const limit = 300;
        const met = used >= limit;
        const text = `${cardBadge("CSR")} Travel (YTD): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(
          0
        )} travel credit (flights/hotels/rideshare on CSR)`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // CSR: StubHub semi-annual ($150 per 6-month period)
      {
        const used = cardState.csrStubhubThisPeriod;
        const limit = 150;
        const met = used >= limit;
        const text = `${cardBadge(
          "CSR"
        )} StubHub/viagogo/soccer.com (this 6-month period): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(0)} semi-annual credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // CSR: Doordash $5/month
      {
        const used = cardState.csrDoordashThisMonth;
        const limit = 5;
        const met = used >= limit;
        const text = `${cardBadge(
          "CSR"
        )} Doordash (this month): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(0)} monthly credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // CSR: Lyft $10/month
      {
        const used = cardState.csrLyftThisMonth;
        const limit = 10;
        const met = used >= limit;
        const text = `${cardBadge(
          "CSR"
        )} Lyft (this month): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(0)} monthly credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // CSR: Peloton $10/month
      {
        const used = cardState.csrPelotonThisMonth;
        const limit = 10;
        const met = used >= limit;
        const text = `${cardBadge(
          "CSR"
        )} Peloton membership (this month): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(0)} monthly credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // UQ: Rideshare $8/month
      {
        const used = cardState.uqRideshareThisMonth;
        const limit = 8;
        const met = used >= limit;
        const text = `${cardBadge(
          "UQ"
        )} Rideshare (other) (this month): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(0)} monthly credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // UQ: Instacart $15/month
      {
        const used = cardState.uqInstacartThisMonth;
        const limit = 15;
        const met = used >= limit;
        const text = `${cardBadge(
          "UQ"
        )} Instacart (this month): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(0)} monthly credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // MB: Dining $25/month
      {
        const used = cardState.mbDiningThisMonth;
        const limit = 25;
        const met = used >= limit;
        const text = `${cardBadge(
          "MB"
        )} Dining (this month): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(0)} monthly dining credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // DG: Delta Stays $100/year
      {
        const used = cardState.dgDeltaStaysYTD;
        const limit = 100;
        const met = used >= limit;
        const text = `${cardBadge(
          "DG"
        )} Delta Stays (YTD): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(0)} annual Delta Stays credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // DG: $10k spend threshold
      {
        const used = cardState.dg10kSpendYTD;
        const limit = 10000;
        const met = used >= limit;
        const text = `${cardBadge(
          "DG"
        )} $10k threshold (YTD): ~$${used.toFixed(
          2
        )} of $${limit.toFixed(
          0
        )} eligible spend toward the $200 Delta Flight Credit`;
        ccLines.push(met ? `<span class="credit-met">${text}</span>` : text);
      }
    
      // ---------- Merchant benefits (merchantState) ----------
      if (benefits.length > 0) {
        const todayStr = formatTodayISO();
        const todayDate = parseISODate(todayStr);
    
        // Sort benefits alphabetically by merchant name (case-insensitive)
        const sortedBenefits = [...benefits].sort((a, b) => {
          const nameA = (a.merchant || "").toLowerCase();
          const nameB = (b.merchant || "").toLowerCase();
          return nameA.localeCompare(nameB);
        });
    
        for (const benefit of sortedBenefits) {
          const ms = merchantState[benefit.id] || { used: 0, limit: null };
          const end = parseISODate(benefit.endDate);
          const expired = end && todayDate && todayDate > end;
    
          const discountLabel =
            benefit.discountType === "percent"
              ? `${Number(benefit.discountValue || 0)}%`
              : `$${Number(benefit.discountValue || 0).toFixed(2)}`;
    
          const hasMinSpend =
            benefit.minSpend != null &&
            !isNaN(benefit.minSpend) &&
            Number(benefit.minSpend) > 0;
    
          let limitLabel = "";
          if (
            benefit.limitType === "per_tx" &&
            benefit.limitValue != null &&
            !isNaN(benefit.limitValue)
          ) {
            limitLabel = `, up to $${Number(benefit.limitValue).toFixed(
              2
            )} per txn`;
          } else if (
            benefit.limitType === "total" &&
            benefit.limitValue != null &&
            !isNaN(benefit.limitValue)
          ) {
            limitLabel = `, up to $${Number(benefit.limitValue).toFixed(2)} total`;
          }
    
          if (hasMinSpend) {
            const msVal = Number(benefit.minSpend).toFixed(2);
            limitLabel += `${limitLabel ? "," : ""} min spend $${msVal}`;
          }
    
          let text;
          if (benefit.limitType === "total" && ms.limit != null) {
            const met = ms.used >= ms.limit;
            const base = `${cardBadge(
              benefit.card
            )} <b>${benefit.merchant}</b> – ${discountLabel}${limitLabel}, used ~$${ms.used.toFixed(
              2
            )}${expired ? " (expired)" : ""}`;
            text = met ? `<span class="credit-met">${base}</span>` : base;
          } else {
            const base = `${cardBadge(
              benefit.card
            )} <b>${benefit.merchant}</b> – ${discountLabel}${limitLabel}, until ${
              benefit.endDate
            }${expired ? " (expired)" : ""}`;
            text = base;
          }
    
          merchantLines.push(text);
        }
      }
    
      // ---------- Render HTML into the section ----------
      let html = "";
    
      if (ccLines.length > 0) {
        html += `
          <div>
            <h3>Credit Card Benefits</h3>
            <ul>
              ${ccLines.map((line) => `<li>${line}</li>`).join("")}
            </ul>
          </div>
        `;
      }
    
      if (merchantLines.length > 0) {
        html += `
          <div style="margin-top:8px;">
            <h3>Merchant Benefits</h3>
            <ul>
              ${merchantLines.map((line) => `<li>${line}</li>`).join("")}
            </ul>
          </div>
        `;
      }
    
      if (!html) {
        html = `<span class="muted">No credits or offers logged yet.</span>`;
      }
    
      el.innerHTML = html;
    }

    // ---------- Core category logic (no merchant override) ----------
    function recommendCardBase(purchase, state) {
      const { category } = purchase;
    
      // DINING
      if (category === "dining") {
        if (state.mbDiningThisMonth < 25) {
          return {
            card: "MB",
            channel: "direct",
            reason: `Use Brilliant first to burn the $25 monthly dining credit (you’ve logged ~$${state.mbDiningThisMonth.toFixed(
              2
            )} so far this month).`,
          };
        }
        return {
          card: "CSR",
          channel: "direct",
          reason:
            "MB dining credit looks used up for this month; default to CSR for flexible points and your stated preference.",
        };
      }
    
      // DOORDASH
      if (category === "doordash") {
        if (state.csrDoordashThisMonth < 5) {
          return {
            card: "CSR",
            channel: "direct",
            reason: `Use CSR first to burn the $5 monthly Doordash/food-delivery credit (you’ve logged ~$${state.csrDoordashThisMonth.toFixed(
              2
            )} so far this month).`,
          };
        }
        return {
          card: "CSR",
          channel: "direct",
          reason:
            "Doordash monthly credit is effectively used; still default to CSR for flexible points here.",
        };
      }
    
      // LYFT
      if (category === "lyft") {
        if (state.csrLyftThisMonth < 10) {
          return {
            card: "CSR",
            channel: "lyft_app",
            reason: `Lyft has about $${(
              10 - state.csrLyftThisMonth
            ).toFixed(
              2
            )} of the $10 monthly CSR Lyft credit left, plus boosted points on Lyft.`,
          };
        }
        return {
          card: "CSR",
          channel: "lyft_app",
          reason:
            "Lyft monthly credit looks used, but CSR still wins here thanks to Lyft boosts and flexibility.",
        };
      }
    
      // OTHER RIDESHARE (Uber, etc.)
      if (category === "rideshare_other") {
        if (state.uqRideshareThisMonth < 8) {
          return {
            card: "UQ",
            channel: "direct",
            reason: `Use United Quest first to burn the $8 monthly rideshare credit (you’ve logged ~$${state.uqRideshareThisMonth.toFixed(
              2
            )} so far this month).`,
          };
        }
        return {
          card: "CSR",
          channel: "direct",
          reason:
            "UQ rideshare monthly credit looks used; default to CSR for flexible points.",
        };
      }
    
      // UNITED FLIGHTS
      if (category === "united_flight") {
        return {
          card: "UQ",
          channel: "united",
          reason:
            "For United flights, use United Quest to get miles, free bags/priority boarding, TravelBank benefits, and PQPs.",
        };
      }
    
      // DELTA FLIGHTS – threshold chasing
      if (category === "delta_flight_threshold") {
        const remaining = Math.max(0, 10000 - state.dg10kSpendYTD);
        if (state.dg10kSpendYTD < 10000) {
          return {
            card: "DG",
            channel: "delta",
            reason: `You marked this as threshold-chasing and you’ve logged ~$${state.dg10kSpendYTD.toFixed(
              2
            )} toward the $10,000 YTD spend. Roughly $${remaining.toFixed(
              2
            )} to go; use Delta Gold here to work toward the $200 Delta Flight Credit.`,
          };
        }
        return {
          card: "CSR",
          channel: "delta",
          reason:
            "You’ve effectively hit the $10k Delta Gold spend threshold this year; treat this like a normal Delta flight and default to CSR for flexibility.",
        };
      }
    
      // DELTA FLIGHTS – normal
      if (category === "delta_flight") {
        return {
          card: "CSR",
          channel: "delta",
          reason:
            "Delta flight booked direct and you’re not treating it as threshold-chasing; default to CSR for travel earn and flexibility.",
        };
      }
    
      // OTHER FLIGHTS
      if (category === "other_flight") {
        return {
          card: "CSR",
          channel: "chase_travel",
          reason:
            "Other airline – book via Chase Travel with CSR to keep travel earn in flexible points (no special airline perks dominating).",
        };
      }
    
      // MARRIOTT HOTELS
      if (category === "marriott_hotel") {
        return {
          card: "MB",
          channel: "direct",
          reason:
            "Direct Marriott stay – use Brilliant for 6x Bonvoy points plus status alignment and Marriott-specific perks.",
        };
      }
    
      // RENOWNED HOTELS
      if (category === "renowned_hotel") {
        return {
          card: "UQ",
          channel: "renowned_chase",
          reason:
            "Renowned Hotels booking – use United Quest to trigger the Renowned credit and boosted United earn.",
        };
      }
    
      // DELTA STAYS
      if (category === "delta_stays") {
        if (state.dgDeltaStaysYTD < 100) {
          const remaining = Math.max(0, 100 - state.dgDeltaStaysYTD);
          return {
            card: "DG",
            channel: "delta_stays_platform",
            reason: `Use Delta Gold at Delta Stays until you’ve used the $100 annual credit (you’ve logged ~$${state.dgDeltaStaysYTD.toFixed(
              2
            )}, about $${remaining.toFixed(2)} remaining).`,
          };
        }
        return {
          card: "CSR",
          channel: "delta_stays_platform",
          reason:
            "Delta Stays annual credit looks used; defaulting to CSR for flexible travel points.",
        };
      }
    
      // OTHER HOTELS / LODGING
      if (category === "other_hotel") {
        return {
          card: "CSR",
          channel: "chase_travel",
          reason:
            "Non-Marriott hotel – book via Chase Travel with CSR to centralize travel earn in flexible points.",
        };
      }
    
      // STUBHUB / VIAGOGO / SOCCER.COM
      if (category === "stubhub") {
        if (state.csrStubhubThisPeriod < 150) {
          const remaining = Math.max(0, 150 - state.csrStubhubThisPeriod);
          return {
            card: "CSR",
            channel: "stubhub_platform",
            reason: `Use CSR on StubHub/viagogo/soccer.com to work through the $150 semi-annual credit (you’ve logged ~$${state.csrStubhubThisPeriod.toFixed(
              2
            )}, about $${remaining.toFixed(2)} remaining this period).`,
          };
        }
        return {
          card: "CSR",
          channel: "stubhub_platform",
          reason:
            "StubHub semi-annual credit looks used; CSR still wins here as default for flexibility.",
        };
      }
    
      // INSTACART
      if (category === "instacart") {
        if (state.uqInstacartThisMonth < 15) {
          const remaining = Math.max(0, 15 - state.uqInstacartThisMonth);
          return {
            card: "UQ",
            channel: "instacart_platform",
            reason: `Use United Quest for Instacart to burn through the $15 monthly Instacart credits (you’ve logged ~$${state.uqInstacartThisMonth.toFixed(
              2
            )}, about $${remaining.toFixed(2)} remaining).`,
          };
        }
        return {
          card: "CSR",
          channel: "instacart_platform",
          reason:
            "Instacart monthly credits look used; defaulting to CSR for flexible points.",
        };
      }
    
      // STREAMING
      if (category === "streaming") {
        return {
          card: "UQ",
          channel: "direct",
          reason:
            "Streaming earns bonus miles on United Quest; after that, CSR stays your general default elsewhere.",
        };
      }
    
      // PELOTON MEMBERSHIP
      if (category === "peloton") {
        if (state.csrPelotonThisMonth < 10) {
          const remaining = Math.max(0, 10 - state.csrPelotonThisMonth);
          return {
            card: "CSR",
            channel: "peloton_platform",
            reason: `Use CSR for Peloton membership to consume the $10 monthly credit (you’ve logged ~$${state.csrPelotonThisMonth.toFixed(
              2
            )}, about $${remaining.toFixed(2)} remaining).`,
          };
        }
        return {
          card: "CSR",
          channel: "peloton_platform",
          reason:
            "Peloton membership monthly credit looks used; CSR remains your default here for simplicity.",
        };
      }
    
      // GENERAL / FALLBACK
      return {
        card: "CSR",
        channel: "direct",
        reason:
          "No special time-bound credit or category perk dominates here, so defaulting to CSR as you requested.",
      };
}

    // ---------- Merchant-first wrapper ----------
    function recommendCard(purchase, cardState, merchantState, benefits) {
      const baseRec = recommendCardBase(purchase, cardState);
    
      if (purchase.merchantBenefitId) {
        const benefit = findBenefitById(purchase.merchantBenefitId, benefits);
        if (benefit) {
          const purchaseDate = parseISODate(purchase.date);
          const end = parseISODate(benefit.endDate);
          const expired = end && purchaseDate && purchaseDate > end;
    
          const ms = merchantState[benefit.id] || { used: 0, limit: null };
          const hasTotalCap =
            benefit.limitType === "total" &&
            benefit.limitValue != null &&
            !isNaN(benefit.limitValue);
    
          const totalLimit = hasTotalCap ? Number(benefit.limitValue) : null;
          const exhausted =
            hasTotalCap && totalLimit != null && ms.used >= totalLimit;
    
          const amount = Number(purchase.amount) || 0;
          const minSpend =
            benefit.minSpend != null && !isNaN(benefit.minSpend)
              ? Number(benefit.minSpend)
              : null;
          const belowMinSpend = minSpend != null && amount < minSpend;
    
          if (!expired && !exhausted && !belowMinSpend) {
            const discountLabel =
              benefit.discountType === "percent"
                ? `${Number(benefit.discountValue || 0)}%`
                : `$${Number(benefit.discountValue || 0).toFixed(2)}`;
    
            // For total-cap benefits, compute remaining for the bullet
            let remaining = null;
            if (hasTotalCap && totalLimit != null) {
              remaining = Math.max(0, totalLimit - ms.used);
            }
    
            return {
              card: benefit.card,
              channel: baseRec.channel, // keep same channel logic as category
              // Main sentence (shown right under "Reason:")
              reasonMain: `Merchant offer at ${benefit.merchant} – ${discountLabel} back in ${benefit.category}.`,
              // Keep a plain reason as a fallback (not actually used by the new renderer)
              reason: `Merchant offer at ${benefit.merchant} – ${discountLabel} back in ${benefit.category}.`,
              // Metadata for bullets:
              remainingAmount: remaining,          // e.g. 12.34
              totalCapAmount: totalLimit,          // e.g. 50.00
              expiresOn: benefit.endDate || null,  // "yyyy-mm-dd"
              priorityCash: true,                  // to show the final sentence
            };
          }
        }
      }
    
      // If benefit is expired, exhausted, or below min spend, fall back to base logic
      return baseRec;
    }


    // ---------- Category select population ----------
    function populateCategorySelect() {
      const select = document.getElementById("category");
      if (!select) return;
    
      // Clear existing options
      select.innerHTML = "";
    
      // Load benefits + txs so we can see what's actually used
      const benefits = loadMerchantBenefits();
      const txs = loadTransactions();
      const merchantState = computeMerchantState(txs, benefits);
    
      const today = parseISODate(formatTodayISO());
    
      // Active merchant offers:
      // - not expired
      // - AND, if they have a total cap, not fully used
      const active = benefits.filter((b) => {
        if (!b.endDate) return false;
        const end = parseISODate(b.endDate);
        if (!end || !today) return false;
        if (end < today) return false;
    
        // Check if fully used for total-cap benefits
        if (
          b.limitType === "total" &&
          b.limitValue != null &&
          !isNaN(b.limitValue)
        ) {
          const ms = merchantState[b.id] || { used: 0, limit: null };
          const limitNum = Number(b.limitValue);
          if (ms.used >= limitNum) {
            // fully used, hide from dropdown
            return false;
          }
        }
    
        return true;
      });
    
      // Sort active benefits alphabetically by merchant name
      active.sort((a, b) => {
        const nameA = (a.merchant || "").toLowerCase();
        const nameB = (b.merchant || "").toLowerCase();
        return nameA.localeCompare(nameB);
      });
    
      // ----- Merchant Offers group (on top) -----
      if (active.length > 0) {
        const offersGroup = document.createElement("optgroup");
        offersGroup.label = "Merchant Offers";
    
        active.forEach((benefit) => {
          const opt = document.createElement("option");
          opt.value = "mb:" + benefit.id;
    
          // Show ONLY merchant name
          opt.textContent = benefit.merchant || "";
    
          offersGroup.appendChild(opt);
        });
    
        select.appendChild(offersGroup);
      }
    
      // ----- Card Benefits group (base categories) -----
      const cardGroup = document.createElement("optgroup");
      cardGroup.label = "Card Benefits";
    
      BASE_CATEGORIES.forEach((cat) => {
        const opt = document.createElement("option");
        opt.value = cat.value;
        opt.textContent = cat.label;
        cardGroup.appendChild(opt);
      });
    
      select.appendChild(cardGroup);
    
      // Default back to Dining / Restaurants if present
      const hasDining = !!select.querySelector('option[value="dining"]');
      if (hasDining) {
        select.value = "dining";
      }
    }

    // ---------- Merchant benefits UI ----------
    function renderMerchantBenefits() {
      const benefits = loadMerchantBenefits();
      const tbody = document.getElementById("benefitsTbody"); // note: lowercase 'b'
      if (!tbody) return;
    
      tbody.innerHTML = "";
    
      const today = parseISODate(formatTodayISO());
    
      benefits.forEach((b, idx) => {
        const tr = document.createElement("tr");
    
        const discountText =
          b.discountType === "percent"
            ? `${b.discountValue}% off`
            : `$${Number(b.discountValue || 0).toFixed(2)} off`;
    
        const parts = [];
        if (b.minSpend != null && !isNaN(b.minSpend) && Number(b.minSpend) > 0) {
          parts.push(`Min $${Number(b.minSpend).toFixed(2)}`);
        }
        if (b.limitValue != null && !isNaN(b.limitValue)) {
          const val = Number(b.limitValue).toFixed(2);
          parts.push(
            b.limitType === "per_tx"
              ? `Up to $${val} / txn`
              : `Up to $${val} total`
          );
        }
        const limitText = parts.join("; ");
    
        const categoryText = b.category || "";
        const endDateText = b.endDate || "";
    
        // Figure out if it's expired
        const end = parseISODate(b.endDate);
        const expired = end && today && end < today;
    
        tr.innerHTML = `
          <td>${b.merchant ? escapeHtml(b.merchant) : ""}</td>
          <td>${b.card ? renderCardBadge(b.card) : ""}</td>
          <td>${discountText}</td>
          <td>${limitText}</td>
          <td>${escapeHtml(categoryText)}</td>
          <td>${endDateText}</td>
          <td>
            <button
              type="button"
              class="deleteBenefitBtn"
              data-benefit-index="${idx}"
            >
              Del
            </button>
          </td>
        `;
    
        if (expired) {
          tr.classList.add("expired-benefit");
        }
    
        tbody.appendChild(tr);
      });
    
      // Wire up delete buttons
      tbody.querySelectorAll(".deleteBenefitBtn").forEach((btn) => {
        btn.addEventListener("click", () => {
          const idx = Number(btn.getAttribute("data-benefit-index"));
          const benefits = loadMerchantBenefits();
          benefits.splice(idx, 1);
          saveMerchantBenefits(benefits);
          renderMerchantBenefits();
          populateCategorySelect(); // keep the New Purchase categories in sync
          renderStateSummary();     // and the top usage summary
        });
      });
    }

    // ---------- UI wiring ----------

    let lastRecommendation = null;

    function initFormDefaults() {
      const dateInput = document.getElementById("date");
      dateInput.value = formatTodayISO();
    }

    function renderRecommendationSection(rec) {
      const recommendationBox = document.getElementById("recommendationBox");
      const reasonBox = document.getElementById("reasonBox");
    
      if (!rec) {
        recommendationBox.innerHTML = "";
        reasonBox.innerHTML = "";
        return;
      }
    
      const cardBadgeHtml = renderCardBadge(rec.card);
      const channelLabel = CHANNEL_LABELS[rec.channel] || rec.channel;
    
      // Recommendation:
      // "Recommendation:" (bold) on first line, then card badge + channel on next line
      recommendationBox.innerHTML =
        `<strong>Recommendation:</strong><br>` +
        `${cardBadgeHtml} – ${escapeHtml(channelLabel)}`;
    
      // Reason:
      // First line: "Reason:" (bold)
      // Next line: main reason text (no badge)
      const mainReason = rec.reasonMain || rec.reason || "";
      let html = `<strong>Reason:</strong><br>${escapeHtml(mainReason)}`;
    
      const bullets = [];
    
      // Bullet 1 (if applicable): "$x.00 remaining of $y.00 available"
      if (
        rec.remainingAmount != null &&
        !isNaN(rec.remainingAmount) &&
        rec.totalCapAmount != null &&
        !isNaN(rec.totalCapAmount)
      ) {
        bullets.push(
          `$${rec.remainingAmount.toFixed(2)} remaining of $${rec.totalCapAmount.toFixed(
            2
          )} available`
        );
      }
    
      // Bullet 2 (if applicable): "Expires yyyy-mm-dd"
      if (rec.expiresOn) {
        bullets.push(`Expires ${rec.expiresOn}`);
      }
    
      if (bullets.length > 0) {
        html +=
          "<ul>" +
          bullets.map((b) => `<li>${escapeHtml(b)}</li>`).join("") +
          "</ul>";
      }
    
      // Final non-bulleted sentence (if applicable)
      if (rec.priorityCash) {
        html += `<p>This cash discount takes priority over the usual points optimization.</p>`;
      }
    
      reasonBox.innerHTML = html;
    }

    // Recommend button
    document.getElementById("btnRecommend").addEventListener("click", () => {
      const amount = document.getElementById("amount").value;
      const date = document.getElementById("date").value;
      const categoryValue = document.getElementById("category").value;
    
      if (!amount || !date) {
        alert("Please enter amount and date.");
        return;
      }
    
      const txs = loadTransactions();
      const cardState = computeState(txs);
      const benefits = loadMerchantBenefits();
      const merchantState = computeMerchantState(txs, benefits);
    
      let purchase;
      let merchantBenefitId = null;
    
      // If category is a merchant benefit (mb:<id>), map to underlying category
      if (categoryValue.startsWith("mb:")) {
        const id = categoryValue.slice(3);
        const benefit = findBenefitById(id, benefits);
        if (!benefit) {
          alert("Selected merchant benefit not found. Try refreshing.");
          return;
        }
        merchantBenefitId = id;
        purchase = {
          amount,
          date,
          category: benefit.category,
          merchantBenefitId: id,
        };
      } else {
        purchase = {
          amount,
          date,
          category: categoryValue,
        };
      }
    
      const rec = recommendCard(purchase, cardState, merchantState, benefits);
      lastRecommendation = { purchase, rec };
    
      // New centralized renderer
      renderRecommendationSection(rec);
      document.getElementById("recommendationSection").style.display = "block";
    
      // Reset override dropdowns
      const cardSel = document.getElementById("cardUsedSelect");
      cardSel.value = "";
    
      const chanSelect = document.getElementById("channelUsedSelect");
      chanSelect.innerHTML = "";
    
      const effectiveCategory = purchase.category;
      const relevantChannels = CHANNELS_BY_CATEGORY[effectiveCategory] || ["direct"];
      relevantChannels.forEach((code) => {
        const opt = document.createElement("option");
        opt.value = code;
        opt.textContent = CHANNEL_LABELS[code] || code;
        chanSelect.appendChild(opt);
      });
    
      if (relevantChannels.includes(rec.channel)) {
        chanSelect.value = rec.channel;
      }
    });

    // Save transaction
    document.getElementById("btnSaveTx").addEventListener("click", () => {
      if (!lastRecommendation) {
        alert("Get a recommendation first.");
        return;
      }
      const overrideCard = document.getElementById("cardUsedSelect").value;
      const overrideChannel = document.getElementById("channelUsedSelect").value;

      const cardUsed = overrideCard || lastRecommendation.rec.card;
      const channelUsed = overrideChannel || lastRecommendation.rec.channel;

      const tx = {
        date: lastRecommendation.purchase.date,
        amount: lastRecommendation.purchase.amount,
        category: lastRecommendation.purchase.category,
        channel: channelUsed,
        cardUsed,
        merchantBenefitId: lastRecommendation.purchase.merchantBenefitId || null,
      };

      const txs = loadTransactions();
      txs.push(tx);
      saveTransactions(txs);
      renderTransactions();
      renderStateSummary();

      alert("Purchase saved.");
    });

    // Reset New Purchase section
    document.getElementById("btnReset").addEventListener("click", () => {
      document.getElementById("amount").value = "";
      initFormDefaults();
      populateCategorySelect();
      document.getElementById("category").value = "dining";

      document.getElementById("recommendationSection").style.display = "none";
      document.getElementById("recommendationBox").textContent = "";
      document.getElementById("reasonBox").textContent = "";

      document.getElementById("cardUsedSelect").value = "";
      const chanSelect = document.getElementById("channelUsedSelect");
      chanSelect.innerHTML = "";

      lastRecommendation = null;
    });

    // Clear all tx
    document.getElementById("btnClear").addEventListener("click", () => {
      if (!confirm("Clear all logged purchases?")) return;
      saveTransactions([]);
      renderTransactions();
      renderStateSummary();
    });

    // Show/Hide Logged Purchases
    const logContent = document.getElementById("logContent");
    const toggleLogBtn = document.getElementById("toggleLogBtn");

    toggleLogBtn.addEventListener("click", () => {
      const isHidden =
        logContent.style.display === "none" || logContent.style.display === "";

      if (isHidden) {
        logContent.style.display = "block";
        toggleLogBtn.textContent = "Hide";
      } else {
        logContent.style.display = "none";
        toggleLogBtn.textContent = "Show";
      }
    });

    // Show/Hide Merchant Benefits
    const benefitsContent = document.getElementById("benefitsContent");
    const toggleBenefitsBtn = document.getElementById("toggleBenefitsBtn");

    toggleBenefitsBtn.addEventListener("click", () => {
      const isHidden =
        benefitsContent.style.display === "none" ||
        benefitsContent.style.display === "";

      if (isHidden) {
        benefitsContent.style.display = "block";
        toggleBenefitsBtn.textContent = "Hide";
      } else {
        benefitsContent.style.display = "none";
        toggleBenefitsBtn.textContent = "Show";
      }
    });

    // Add merchant benefit
    document.getElementById("btnAddBenefit").addEventListener("click", () => {
      const merchant = document.getElementById("benefitMerchant").value.trim();
      const card = document.getElementById("benefitCard").value;
      const discountType = document.getElementById("benefitDiscountType").value;
      const discountValueRaw = document.getElementById("benefitDiscountValue").value;
      const limitType = document.getElementById("benefitLimitType").value;
      const limitValueRaw = document.getElementById("benefitLimitValue").value;
      const minSpendRaw = document.getElementById("benefitMinSpend").value;
      const endDate = document.getElementById("benefitEndDate").value;
      const category = document.getElementById("benefitCategory").value;

      if (!merchant || !card || !discountType || !discountValueRaw || !endDate || !category) {
        alert("Please fill at least Merchant, Card, Discount type/value, End date, and Category.");
        return;
      }

      const discountValue = Number(discountValueRaw);
      if (isNaN(discountValue) || discountValue <= 0) {
        alert("Discount value must be a positive number.");
        return;
      }

      let limitValue = null;
      if (limitValueRaw !== "") {
        limitValue = Number(limitValueRaw);
        if (isNaN(limitValue) || limitValue < 0) {
          alert("Discount limit value must be a non-negative number.");
          return;
        }
      }

      let minSpend = null;
      if (minSpendRaw !== "") {
        minSpend = Number(minSpendRaw);
        if (isNaN(minSpend) || minSpend < 0) {
          alert("Minimum spend must be a non-negative number.");
          return;
        }
      }

      const id = "mb_" + Date.now() + "_" + Math.floor(Math.random() * 1000);

      const newBenefit = {
        id,
        merchant,
        card,
        discountType,
        discountValue,
        limitType,
        limitValue,
        minSpend,
        endDate,
        category,
      };

      const benefits = loadMerchantBenefits();
      benefits.push(newBenefit);
      saveMerchantBenefits(benefits);

      // Clear inputs
      document.getElementById("benefitMerchant").value = "";
      document.getElementById("benefitDiscountValue").value = "";
      document.getElementById("benefitLimitValue").value = "";
      document.getElementById("benefitMinSpend").value = "";
      document.getElementById("benefitEndDate").value = "";

      renderMerchantBenefits();
      populateCategorySelect();
      renderStateSummary();
    });

      // Init on load
      initFormDefaults();               // sets date to today
      renderTransactions();
      renderMerchantBenefits();
      populateCategorySelect();         // build Merchant Offers + Card Benefits
      
      // Default category to Dining / Restaurants on first load
      const categorySelect = document.getElementById("category");
      if (categorySelect) {
        categorySelect.value = "dining";
      }
      
      renderStateSummary();
  </script>
</body>
</html>
